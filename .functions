# shellcheck disable=SC2148

# go to dotfiles location
dot() {
  # shellcheck disable=SC2164
  cd "${DOTFILES_REPO_DIR:-${HOME}/dotfiles}"
}

# install dotfiles
dot-install() {
    stow -d "${DOTFILES_REPO_DIR:-${HOME}/dotfiles}" -t "${HOME}" .
    
    # Auto-source shell configuration based on $SHELL
    if [[ "${SHELL}" == *zsh* ]]; then
        source "${HOME}/.zshrc"
    elif [[ "${SHELL}" == *bash* ]]; then
        source "${HOME}/.bashrc"
    fi
}

# uninstall dotfiles
dot-uninstall() {
    stow -d "${DOTFILES_REPO_DIR:-${HOME}/dotfiles}" -t "${HOME}" -D .
}

# pull the latest dotfiles and install them
dot-sync() {
  (cd "${DOTFILES_REPO_DIR:-${HOME}/dotfiles}" && git pull)
  dot-install
}

# add a persisten env var 
dot-add-env() {
    local env_file input name value
    if [[ "$1" == "--local" ]]; then
        env_file="${DOTFILES_REPO_DIR:-${HOME}/dotfiles}/.local_config"
        input="$2"
        if [[ "$input" == *"="* ]]; then
            name="${input%%=*}"
            value="${input#*=}"
        else
            name="$2"
            value="$3"
        fi
    else
        env_file="${DOTFILES_REPO_DIR:-${HOME}/dotfiles}/.env"
        input="$1"
        if [[ "$input" == *"="* ]]; then
            name="${input%%=*}"
            value="${input#*=}"
        else
            name="$1"
            value="$2"
        fi
    fi
    echo "export ${name}=${value}" >> "$env_file"
}

# prune all local branches that do not have a remote anymore
git-prune-local() {
    git fetch -p
    git branch -vv | awk '/: gone]/{print $1}' | xargs -r git branch -D
}

# set lima machine for podman
podman-use-lima() {
    limactl start podman
    podman system connection default podman
    sudo rm /var/run/docker.sock
    sudo ln -s "${HOME}/.lima/podman/sock/podman.sock" /var/run/docker.sock
}

# set default machine for podman
podman-use-default() {
    podman system connection default podman-machine-default-root
    sudo rm /var/run/docker.sock
    sudo ln -s "${HOME}/.local/share/containers/podman/machine/podman.sock" /var/run/docker.sock
}

# find files with name in the specified directory
lg() {
    if [ $# -eq 1 ]; then
        # Only pattern provided, use current directory
        la | grep -E "$1"
    elif [ $# -eq 2 ]; then
        # Directory and pattern provided
        la "$1" | grep -E "$2"
    else
        echo "Usage: lg [directory] pattern"
        return 1
    fi
}

# Convert MOV to MP4 with flexible input/output handling
mov_to_mp4() {
    if [ $# -eq 0 ] || [ $# -gt 2 ]; then
        echo "Usage: mov_to_mp4 <input.mov> [output.mp4]"
        echo "Example: mov_to_mp4 video.mov video.mp4"
        return 1
    fi
    
    local input="$1"
    local output="${2:-${input%.*}.mp4}"
    
    if [ ! -f "$input" ]; then
        echo "Error: Input file '$input' not found"
        return 1
    fi
    
    echo "Converting: $input -> $output"
    ffmpeg -i "$input" -c:v libx264 -crf 23 -c:a aac -b:a 128k "$output"
    echo "Successfully converted $input -> $output"
}

# Cut video segment with time format
cut_video() {
    if [ $# -lt 3 ]; then
        echo "Usage: cut_video <input_file> <start_time> <end_time> [output_file]"
        echo "Time format: mm:ss or hh:mm:ss"
        echo "Example: cut_video video.mp4 cut.mp4 0:05 1:15"
        return 1
    fi
    
    local input="$1"
    local start="$2"
    local end="$3"
    local output="${4:-${input%.*}_${start}-${end}.mp4}"
    
    if [ ! -f "$input" ]; then
        echo "Error: Input file '$input' not found"
        return 1
    fi
    
    ffmpeg -i "$input" -ss "$start" -to "$end" -c copy "$output"
    echo "Cut video from $start to $end as $output"
}

# Generate gif from video with optional start and end time
gif() {
    if [ $# -lt 1 ] || [ $# -gt 4 ]; then
        echo "Usage: gif <input_file> [output_file] [start_time] [end_time]"
        echo "If no start/end specified: converts entire video to GIF"
        echo "Time format: mm:ss or hh:mm:ss"
        echo "Example: gif video.mp4 video.gif 0:05 1:15"
        return 1
    fi
    
    local input="$1"
    local output="${2:-${input%.*}.gif}"
    local start="$3"
    local end="$4"
    local conversion_format="fps=15,scale=1920:-1"
    
    if [ ! -f "$input" ]; then
        echo "Error: Input file '$input' not found"
        return 1
    fi

    if [ -z "$start" ]; then
        # Convert entire video
        ffmpeg -i "$input" -vf "$conversion_format" -loop 0 "$output"
        echo "Converted entire video as $output"
    elif [ -z "$end" ]; then
        # Extract segment
        ffmpeg -i "$input" -ss "$start" -vf "$conversion_format" -loop 0 "$output"
        echo "Converted video from $start as $output"
    else
        # Extract segment
        ffmpeg -i "$input" -ss "$start" -to "$end" -vf "$conversion_format" -loop 0 "$output"
        echo "Converted video from $start to $end as $output"
    fi
}

# Return the size of a given path
size() {
    if [ -z "$1" ]; then
        echo "Usage: size <directory_or_file>"
        return 1
    fi
    
    if [ ! -e "$1" ]; then
        echo "Error: '$1' does not exist"
        return 1
    fi
    
    if [ -d "$1" ]; then
        echo "Content Size:"
        du -sh "$1"/* 2>/dev/null | sort -hr
    fi
    
    echo "Size:"
    du -sh "$1" 2>/dev/null
}

# Return the machine public IP
myip() {
    if command -v ip >/dev/null 2>&1; then
        # Linux
        ip route get 1 | awk '{print $7}'
    elif command -v ifconfig >/dev/null 2>&1; then
        # macOS and other Unix systems
        local default_interface
        default_interface=$(route -n get default 2>/dev/null | grep interface | awk '{print $2}')
        ifconfig "$default_interface" 2>/dev/null | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}'
    else
        # Fallback for systems without ip/ifconfig
        echo "Error: Neither 'ip' nor 'ifconfig' command found"
        return 1
    fi
}

myip-global() {
    # Try multiple methods to get public IP
    if command -v curl >/dev/null 2>&1; then
        curl -s https://api.ipify.org
    else
        # Fallback to local IP if no external tools available
        echo "Error: please install 'curl'"
        return 1
    fi
}